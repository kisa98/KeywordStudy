디자인 패턴
-> 모범 설계 방법

일반화: 상속
실체화: 가상 클래스를 상속받아 자식 클래스를 만드는 것.
의존(사용): 객체 내부에 저장하지 않고 사용함
연관(has-a): 객체 내부에 참조를 저장함

전방 선언: 전방 선언은 객체의 크기나 구체적인 내용을 알 필요 없이 컴파일러가 해당 객체의 존재를 알 수 있도록 합니다. 이를 통해 컴파일러는 객체의 포인터 또는 참조를 사용할 수 있습니다.

옵저버 패턴은 인터페이스 사용이 중요한가? 
포인터를 파라미터로 쓰고 벡터 컨테이너로 쓰는 이유: 복사 안해도 되고 참조하기 쉬움, 시간적, 공간적 이득
생성자는 가상화할 수 없다 : 가상 함수는 컴파일 시점에 가상 함수 테이블이 생성되고, 객체가 가진 가상 포인터를 이용해 함수를 참조한다. 그런데 가상 포인터는 생성자가 호출된 이후에 생긴다. 생성자가 호출되는 시점엔 가상 포인터가 없어서, 가상 함수 테이블을 이용할 수 없다.

가상함수 테이블: 추상 클래스가 가상 함수를 갖고 있을 때, 컴파일러는 해당 함수들의 포인터를 저장하는 가상함수포인터를 정의한다. 이후 객체가 실체화될 때, 가상 포인터를 생성하고 그 가상 포인터로 가상 함수 테이블의 함수를 찾아 호출한다.

생성자의 추상화 금지 : 가상 함수는 주로 기반 클래스 포인터를 통해 파생 클래스의 함수를 호출하기 위해 사용됩니다. 그러나 생성자는 객체를 생성할 때 직접 호출되므로, 기반 클래스 포인터를 사용할 수 없습니다.


가상함수와 그 구현 함수가 static일 수 없는 이유?
static 함수는 클래스에 속하지만, 특정 객체 인스턴스에 속하지 않습니다.
이는 객체 없이 클래스 이름을 통해 호출됩니다.

static 함수는 객체의 인스턴스 멤버 변수에 접근할 수 없습니다.
이는 클래스 레벨에서 동작하며, 객체의 특정 상태와는 무관합니다.

static 함수는 객체에 특정하지 않으므로, 객체의 가상 포인터도 알 수 없다. 따라서 추상함수따위 사용할 수 없다...


C++
객체: 메모리가 할당된 클래스의 변수
Object obj; 	//정적 할당 객체
Object* obj = new Object()	//동적할당 객체

C#
객체: 인스턴스의 참조값을 저장하는 변수 - 참조 타입 - 기본적으로 참조해서 가져간다
인스턴스:: 클래스를 동적할당하여 만들어진 참조된 대상
적이 플레이어를 추적할 때, 객체 : 타겟이 담길 변수, 인스턴스 : 플레이어 오브젝트

Class(클래스): 객체는 참조자고 객체를 사용하려면 객체를 할당하거나 참조해야한다
Object obj = new Object();
객체(참조자) = 인스턴스
독수리가 참조하는 타겟인 플레이어 인스턴스는, 타겟을 발견했을 때만 추적한다.


Struct(구조체) : 객체가 정적할당된다 - 값 타입 - 기본적으로 복사해서 가져간다
Struct str = new Struct()
객체(정적 할당) = 생성자 호출(객체에 값을 할당)


상속할 때 부모의 부분을 선언하지 않아도 되는 이유 : 부모 위에 자식 객체에 추가 메모리를 할당한다
오버라이딩 : 가상 함수를 구현하는 것
ㄴ 함수 포인터에 할당된 참조하는 함수의 주소값이 바뀌는 것
delegate : 

오버로딩 : 같은 함수를 여러 형태로 선언
스택 오버플로우 : 정적 할당된 메모리가 너무 많아져 스택의 크기보다 많이 할당함 -단순 반복이 많은 기능에 재귀를 잘못하면 메모리가 터질 수 있다는 단점이 있다

재귀를 써야할 때: 트리 -> 탐색 : 스택을 쓰지 않기 위해서 - 함수가 호출될때마다 지역변수가 스택에 할당되어 이전의 데이터에 접근할 수 있어서

추상 클래스 : 순수 가상 함수를 한 개라도 포함하고 있는 클래스 - 객체 생성 불가

실제 소프트웨어의 설계에서는 실제 현상이나 추상적인 것을 꼭 따를 필요는 없다. 
실제 상속받아 사용할 작업자의 편리성을 고려하는 것이 나을 수 있다.
객체 지향 문법을 따라서 반드시 지킬 필요는 없음을 인지해야한다.

