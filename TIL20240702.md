# 용어 및 개념 추가 
## 나중에 정리 좀 할 것

SDL검사 : 프로그래밍 입출력 안전성 검사
void*(Void Pointer): 타입이 없는 포인터.
변수에 타입이 필요한 이유: 저장되는 변수의 종류에 따라 할당되는 메모리가 다름. 메모리를 관리하고 접근하기 위해 변수 타입이 필요함, 또 변수마다 처리 방식(디코딩 방식)이 다르기 때문
변수에 표현범위가 있는 이유: 이진수로 나타남. 이진수 범위에 맞춰서 값을 나타내야 하기 때문.
간디가 폭력적인 이유: 오버플로우, 언더플로우32비트, 
64비트: 32비트는 메모리를 4기가 까지밖에 못쓴다. 2^32 = 4기가라서(포인터의 크기가 4기가를 넘을 수 없다. 메모리를 포인터로 0~4기가 까지 밖에 못쓴다)
32비트가 메모리를 4기가밖에 못쓰는 이유? 32비트는 메모리를 32비트 이진수로 표현함. 그렇다보니 2^32개만큼 표기할 수 있는데, 그게 4기가바이트임. 그러니까 메모리를 최대 4기가바이트 갯수밖에 할당할 수가 없음.
long pointer: 16비트 시스템에서 주소 공간이 너무 작아서(64kb), 더 큰 주소를 참조하기 위해 고안한 방식. 세그먼트와 오프셋을 이용함. 16비트의 메모리로 32비트 주소 공간을 만듬 
printf할 때, 표현 방법을 정해 줘야하는 이유? 메모리는 데이터 덩어리, 디코딩 단계에서  어떻게 해석하느냐에 따라 달라진다.
치트 엔진: 메모리 위치를 읽어 값을 덮어씌움.
메모리 난독화: 메모리에 저장된 데이터의 형식을 변환하여 원래 데이터의 의미를 숨긴다
Serialize: (구현해보면 좋음) 직렬화는 데이터를 저장, 전송하기 위해 데이터를 바이너리 또는 스트링으로 변환하는 것

운영체제 배우는 이유? 엔진은 운영 체제에서 돌아감. 게임도 운영 체제에서 돌아감.

malloc? 보이드 포인터로 선언한 후, 캐스팅 연산자로 메모리 크기를 지정한다. 
동적할당: 프로그램이 실행되는 동안 메모리를 할당하는 방식
정적할당: 프로그램이 컴파일 될 때 메모리가 할당되는 방식. 
메모리누수: 동적할당 된 메모리를 해제하지 않아, 할당할 수 없는 상태가 된다. -> 안드로이드에서 있었던 문제
메모리 외부 단편화: 가용 메모리는 있으나, 빈 공간이 조금씩 발생하여 큰  프로세스의 연속 메모리를 할당할 수 없는 상태 - 메모리에 충분한 공간이 있으나, 연속된 크기가 프로세스보다 작아서 할당하지 못하는 문제 -> Compaction(비추)와 Paging기법으로 해결, 할당하고자 하는 메모리를 고정된 크기의 페이지 단위로 쪼개고, 물리 메모리의 프레임에 매핑한다

쓰레드 PPT에 있는 WinAPI 데모를 큐로 바꿔서 처리시키기 
WindowProgramming 깃 갱신하기
Task의 도래 -> 프로세스와 스레드가 경쟁 상태에 도달하는 것을 예방하기 위해
코루틴 : 열거자 IEnumerator을 반환하는 메서드= 함수의 제어를 메인 스레드(Update같은)에 편승하여 협력적 멀티 태스킹을 통해 실행. 작업 실행을 일시 정지하고 제어를 유니티에 반환했다가, 다음 프레임에 계속하는 식 (기존 함수들은 한 프레임 내에서 완료해야함)
IEnumerator: 컬렉션을 단순하게 반복할 수 있도록 지원하는 인터페이스, 유니티에서 열거자는 반복적인 작업을 처리하기 위해 사용되는 인터페이스. 유니티에서 열거자는 yield return 구문을 사용하여 코루틴 내에서 중단점들을 정의하고, 이 중단점에서 다음 프레임이나 특정 시간 후에 작업을 계속할 수 있다. 약간 다른 느낌. (yield return을 중단점으로 하는 작업들 컬렉션을 열거해놓는다고 보고, 그걸 코루틴이 제어한다고 보면 비슷할지도? 
싱글 스레드, 멀티 스레드, 잡스케줄러
context switching: CPU에 실행할 프로세스를 교체하는 기술이다. 프로세스 스케줄링에서 프로세스를 계속해서 바꿔주는 기술들에 사용되는 게 바로 컨텍스트 스위칭이다. 
스레드 속도 < 태스크 속도 , 왜? 스레드는 CPU에 여러 흐름을 만들어 컨텍스트 스위칭으로 인해 느려짐(하드웨어가 스케줄링 하게 만들면 느려짐),
태스크는 왜 빠른지- 오버헤드가 적어서, (스레드와 태스크가 잡 스케줄링 차이라는점.)
태스크가 더 경량함. 태스크 컨텍스트 스위칭은 스레드 풀 내에서 작업 전환, 스레드는 스레드 간 컨텍스트 전환이라 비용차이가 있음 -> 구현을 하던가 뭐 하던가 해봐야할듯
오버헤드: 컨텍스트 스위칭 비용. (사실 쓸모없이 낭비되는 비용들을 말함)
프로세스: 실행중인 프로그램 인스턴스. 작업 관리자에 프로세스 종료 들어가면 어플리케이션이 나오는 그거임
스레드: 프로세스 내에서 실행되는 작업의 주체
태스크: 스레드가 수행할 작업 단위. 

멀티태스킹 : 운영 체제가 여러 프로세스를 실행하는 것.(Task랑 관계 없음.)
멀티스레딩: 프로세스 내에서 여러 스레드가 태스크를 처리하는 것

잡스케줄러: 작업을 효율적으로 관리하는 소프트웨어 또는 기법(잡 스케줄링). 프로세스, 스레드 단위로 약간 다를 수 있음 
asnyc? 작업을 비동기적으로 수행하여, 작업이 완료될때까지 기다리지 않고 작업하도록 프로그래밍하는 기법
=> 멀티스레딩을 쓸 수도 있고, 단일 스레드에서 이벤트 루프라는 방법으로 쓸 수 있음. 대표적으로 유니티의 코루틴 
CPU, GPU, NPU
CPU 에서 스레드 처리방식:
듀얼코어, 멀티코어에서 게임 처리 방식
리틀 앤디언, 빅 앤디언 
