그래픽 API
ㄴOpenGL: 범용 OS용 그래픽 라이브러리
ㄴㄴES: 모바일과 같은 저사양 기기에서 작동하도록 만들어진 라이브러리
ㄴDirectX: Window 전용 그래픽 라이브러리

라이브러리: 외부에서 제공되는 기능을 활용하여 개발하기 위한것
ㄴ 소스코드의 헤더파일만 공유하고 cpp파일을 빌드하여 lib파일로 빌드한 것

x86: 32비트
x64: 64비트
ARM: 모바일 프로세서

링크: 소스 코드가 빌드되고 사용할 라이브러리를 연결시키는 것.

2. 버텍스 예제, 
ㄴ버텍스: 3D 모델을 만들기 위해 정의된 점,
버텍스 버퍼: 이 버텍스의 모음, 
디바이스: 3D 디바이스(GPU), 
디바이스 초기화: 3D 디바이스를 사용할 구조체 초기화
버텍스 버퍼 초기화: 버텍스들의 위치와 색상을 정하고, 배열을 GPU에 복사함
렌더링: 후면 버퍼 초기화 -> 후면 버퍼에 버텍스 버퍼를 그린다. 후면 버퍼를 전면 버퍼랑 교체함(이증 버퍼링) -> 플리커 방지
외적: 두 벡터에 모두 수직인 벡터 -> 면의 방향 결정, 백페이스 컬링, 라이팅 계산, 충돌 감지등에 필요함
내적: 두 벡터 사이의 내각 크기
평면: 수학적 평면은 무한한 평면으로 원점과 방향을 갖고 있다.
평면과 점의 관계
ㄴ 평면과 점이 예각이면 평면보다 위에 있다
ㄴ 평면과 점이 둔각이면 평면보다 아래에 있다
ㄴ 평면과 점이 직각이면 평면에 걸쳐있다.

렌더링 파이프라인: 3d 물체가 카메라에 그려지는 과정
ㄴ로컬 행렬: 자기 자신을 기준으로 위치를 나타내는 것
ㄴ월드 행렬: 세상을 기준으로 정렬되는 위치
ㄴ뷰 행렬: 보이는 기준으로 물체의 위치를 나타내는 것
ㄴ프로젝션 행렬: 버텍스를 2d 좌표로 그릴 수 있도록 위치를 나타내는 것

텍스쳐 코드(Coord) - uv좌표: 버텍스마다 텍스쳐가 발라질 위치

빌보드: 카메라를 항상 바라보는 평면
절두체: 카메라의 원근 평면을 포함한 시야 시각 범위 (끝부분이 잘린 피라미드)
높이맵: 지형을 나타내기 위하여 이미지에 색상 정보를 활용하여 높이를 표시함
행렬 요소: 3x3은 회전, 4x3은 
LOD:: 카메라에 따라 버텍스를 조절하여 렌더링 성능을 높이는 것
쿼드트리: 자식이 4개인 트리구조를 이용해 평면위에 검색해야하는 범위를 나누어 검색 속도를 높임
옥타트리: 3차원 구조에서 필요한 평면을 검색하여 범위를 나누어 검색 속도를 향상시킨 방법
컬링: 특정 규칙에 따라 평면을 렌더링하지 않는 것


1. d3d9를 빌드하기 위해 설정한 이유? 
- direct x 라이브러리와 외부 기능을 사용하기 위해 참조를 미리 알려줘야함
2. 버텍스 버퍼를 디바이스에 복사할 때 Lock을 한 이유?
- 여러 코드가 같은 메모리를 동시에 수정하여 생기는 오류를 방지하기 위해(경쟁 상태 방지)
3. 3D 디바이스가 필요한 이유는?
- 그래픽 렌더링에 많은 리소스가 소요되기 때문에 CPU 대신 그래픽 렌더링만 처리해줄 기기가 필요했음
4. 이중 버퍼링이 필요한 이유
- 후면 버퍼를 전면 버퍼와 교체하여 깜빡이는 플리커 현상을 방지할 수 있음
5. 면의 연결 순서가 바뀌면 면이 뒤집히는 이유
- 정점으로 만들어진 벡터들의 외적 결과가 반대로 바뀜(노멀 벡터의 방향이 바뀜) -> 백페이스 컬링을 적용하면 뒷면이 사라지게 됨. directx9에서는 정점 순서가 CW(시계), CCW(반시계)인지로 컬링하는데, 정점 순서가 바뀌면 반대가 되므로 렌더링이 안됨.
6. 평면에서의 노말은 어떻게 결정?
- 평면을 이루는 벡터들을 외적하여 얻음
7. 소프트웨어에서 GPU에 접근하기 위해 필요한 것은 무엇이고, 왜 필요한가?
- 그래픽스 API, GPU의 복잡한 기능을 사용할 수 있게 해주는 기능들이 내장되어있기 때문에 사용해야한다.
8. 원점과의 거리와 어떤 노말 벡터가 주어지면 무한한 평면을 만들 수 있는 이유
- 일정한 거리와 특정 법선 벡터를 갖는 벡터들의 조합이 무수히 많기 때문
9. 기하학(Geometry)는 무엇을 의미하는가
- 그래픽스에서 정점, 벡터, 행렬 등으로 모델을 화면에 렌더링하기 위해 존재하는 구성 요소들
10. 렌더링 파이프라인에 각 좌표 변환이 일어나는 이유는?
ㄴ 월드: 물체를 월드 좌표 기준으로 위치를 지정하기 위해서
ㄴ 뷰: 월드 행렬에 있는 물체를 렌더링 하기위해 카메라 화면 기준으로 정렬한다
ㄴ 프로젝션: 뷰 행렬에 있는 물체를 화면에 2D 픽셀로 정렬하기 위해 
11. 카메라에서 원근감이 느껴지게 되는 이유
12. x 파일에 구성 요소
ㄴ버텍스 버퍼: 메시를 이루는 정점들의 모임
ㄴ인덱스 버퍼: 정점들을 인덱스로 저장하여 삼각형을 이루는 정점으로 사용함
ㄴ텍스쳐 코드 버퍼( Coords): 정점에 적용될 텍스쳐의 좌표(UV 좌표)
13. 텍스쳐 코드 값이 0~1인 값인 이유 
- 텍스쳐 전체 크기를 1로 두고 정규화하여 사용하기 때문.
14. UV 애니메이션이 작동하는 원리
-
15. 빌보드란?
- 물체가 카메라의 정면을 바라보게하여 항상 물체의 전면만 보이게하는 기술(나무, UI 같은데 사용)
16. 빌보드와 카메라의 회전이 동기화되는 방법
- 카메라의 속성을 나타낸 4x4 행렬 중 회전을 담당하는 3x3의 회전 행렬 중 필요한 축 행렬의 값을 가져와 역행렬을 곱한다.
17. 임시 객체를 사용하지 않으면 컴파일 오류가 발생하는 이유
- 포인터에서 값을 추출하는 연산은 안전한 사용을 위해 포인터에 저장된 객체( l value) 를 사용해야한다. 객체에 저장되지 않은 임시 값의 안전성을 보장할 수 없기 때문에 컴파일 오류가 발생한다.
18. 높이 맵이 생성되는 원리
- 높이맵 이미지가 가진 픽셀들의 밝기로 지형의 높이를 결정함
19. 쿼드트리를 사용하여 컬링하는 이유
- 모든 리소스를 로딩하면 성능상 부담이 되므로 렌더링할 요소와 하지 않을 요소를 쿼드 트리(4진 트리)에 넣은 후 결정한다.
20. 절두체 컬링을 위하여 평면이 절두체 안에 있는지 판단을 어떻게 하는지 설명하시오
- 평면이 절두체 내부에 있는지 판단을 해서 컬링 상태를 결정한다. 평면의 점과 절두체 평면 6개의 거리를 비교하면 해당 도형이 절두체 내부에 있는지 외부에 있는지 알 수 있음. 정점과 평면과의 거리가 하나라도 음수(법선 벡터와 반대 방향이)라면 절두체 외부에 있는 상태. 
21. LOD란?
- Level of Detail은 렌더링 성능을 향상시키기 위해 멀리 있는 물체의 디테일을 낮추고, 가까운 물체의 디테일은 높이는 기술. 삼각형 렌더링 기법의 경우 삼각형 크기가 달라짐.

